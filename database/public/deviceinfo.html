<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <title>Informaci√≥n de dispositivo - KYROS</title>
    <link rel="icon" href="images/logo.ico" type="image/x-icon" />
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.5.0"></script>
    <!-- CSS -->
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <!-- Navbar -->
    <nav class="navbar navbar-expand-lg fixed-top navbar-dark">
        <div class="container-fluid">
            <a class="navbar-brand me-auto" href="index.html">
                <img src="images/logo.png" height="40px" alt="KYROS logo">
                <h3 class="logoH">KYROS</h3>
            </a>
            <div class="offcanvas offcanvas-end" tabindex="-1" id="offcanvasNavbar" aria-labelledby="offcanvasNavbarLabel">
                <div class="offcanvas-header">
                    <h5 class="offcanvas-title" id="offcanvasNavbarLabel">KYROS</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
                </div>
                <div class="offcanvas-body">
                    <ul class="navbar-nav justify-content-center flex-grow-1 pe-3">
                        <li class="nav-item">
                            <a class="nav-link mx-lg-2" aria-current="page" href="index.html">Inicio</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link mx-lg-2 active" href="rooms.html">Habitaciones</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link mx-lg-2" href="security.html">Seguridad</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link mx-lg-2" href="automatize.html">Automatizaci√≥n</a>
                        </li>
                    </ul>
                </div>
            </div>
            <a href="login.html" class="login-button">Iniciar sesi√≥n</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasNavbar" aria-controls="offcanvasNavbar" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
        </div>
    </nav>
    <!-- End navbar -->

    <!-- Content -->
    <div class="container" id="main-container-deviceinfo">
        <div class="row">
            <!-- Breadcrumb -->
            <nav class="d-flex">
            <h6 class="mb-0" id="breadcrumb">
                <a href="index.html" class="text-reset">Inicio</a>
                <span>></span>
                <a href="rooms.html" class="text-reset">Habitaciones</a>
                <span>></span>
                <a href="#" class="text-reset" id="roomRoute" onclick="sendName()"></a>
                <span>></span>
                <a href="#" class="text-reset" id="deviceRoute"></a>
            </h6>
            </nav>
            <!-- Breadcrumb -->
        </div>
        <div class="row">
            <div class="row align-items-center mb-2">
                <div class="col-auto d-flex align-items-center">
                    <h1 class="heading mb-0" id="deviceName"></h1>
                    <span id="title-live-value" class="badge rounded-pill bg-primary ms-3 fs-5" style="display: none; font-weight: 500;">
                        --
                    </span>
                </div>
            </div>
        </div>
        <div class="row">
            <div class="col-lg-8">
                
                <div class="d-flex justify-content-end mb-3">
                    <div class="btn-group" role="group" aria-label="Rango de tiempo">
                        <button type="button" class="btn btn-outline-primary active" onclick="changeTimeRange('24h')" id="btn-24h">24H</button>
                        <button type="button" class="btn btn-outline-primary" onclick="changeTimeRange('7d')" id="btn-7d">Semana</button>
                        <button type="button" class="btn btn-outline-primary" onclick="changeTimeRange('30d')" id="btn-30d">Mes</button>
                    </div>
                </div>

                <div id="chart-container" style="position: relative;">
                    <canvas id="myChart" style="width:100%;max-width:700px"></canvas>
                    <div id="chart-overlay" style="display: none; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background: rgba(255,255,255,0.85); justify-content: center; align-items: center; flex-direction: column;">
                        <div class="spinner-border text-primary mb-2" role="status"></div>
                        <span class="text-muted">Esperando datos...</span>
                    </div>
                </div>

                <div id="history-container" style="display: none;">
                    <h5 class="mb-3">Historial de Eventos</h5>
                    <div class="list-group" id="history-list">
                        <div class="list-group-item text-center text-muted">Cargando historial...</div>
                    </div>
                </div>
            </div>
            <div class="col-lg-4">
                <!-- Toggle encendido/apagado - visible para dispositivos que lo soporten -->
                <div id="toggle-section" class="tasks d-flex justify-content-between" style="display: none;">
                    <div class="text">
                        <h6 id="taskname">Cargando...</h6>
                    </div>

                    <label class="switch">
                        <input type="checkbox" id="device-toggle">
                        <span class="slider round"></span>
                    </label>
                </div>

                <!-- Secci√≥n de tareas - solo visible para actuadores -->
                <div id="tasks-section" style="display: none;">
                    <h5>Tareas</h5>
                    <div class="addtask d-flex justify-content-between" onclick="sendTaskInfo()">
                        <div class="text">
                            <h6>Agregar tarea</h6>
                        </div>

                        <div class="add-image">
                            <img src="images/Copy-2--Streamline-Flex.png">
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- End content -->

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-3 col-sm-6">
                    <div class="single-box">
                        <img src="images/logo.png" alt="KYROS logo" height="40px">
                        <h3 class="logo-h3">KYROS</h3>
                        <p>Manten el control sobre tu hogar</p>
                    </div>
                </div>
                <div class="col-lg-3 col-sm-6">
                    <div class="single-box">
                        <h2>Soporte</h2>
                        <ul>
                            <li><a href="helpcenter.html">Centro de ayuda</a></li>
                        </ul>
                    </div>
                </div>
                <div class="col-lg-3 col-sm-6">
                    <div class="single-box">
                        <h2>Cont√°ctenos</h2>
                        <p>687-123-4567</p>
                        <p>kyros.iot@gmail.com</p>
                    </div>
                </div>
            </div>

            <div class="row">
                <h3 class="copyright">&copy;2025 Instituto Tecnol√≥gico Superior de Guasave</h3>
            </div>
        </div>

    </footer>
    <!-- End footer -->

    <!-- Bootstrap JavaScript -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/js/bootstrap.bundle.min.js" integrity="sha384-FKyoEForCGlyvwx9Hj09JcYn3nv7wiPVlz7YYwJrWVcXK/BmnVDxM+D2scQbITxI" crossorigin="anonymous"></script>

    <!-- SweetAlert Javascript -->
    <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>

    <!-- Auth utility -->
    <script src="js/auth.js"></script>
    <script src="js/navbar.js"></script>

    <script>
        requireAuth();

        // --- VARIABLES GLOBALES ---
        let myChart = null;
        let deviceData = null;
        let historicalData = []; // Datos completos para vida √∫til
        let aggregatedData = []; // Datos agregados para gr√°ficas
        let currentTimeRange = '24h';
        let cachedData = {
            '24h': { historical: [], aggregated: [] },
            '7d': { historical: [], aggregated: [] },
            '30d': { historical: [], aggregated: [] }
        }; // Cach√© de datos por rango de tiempo
        let isLoadingData = false; // Indicador de carga

        // --- UTILIDADES DE RED ---
        // Wrapper para fetch con timeout
        async function fetchWithTimeout(url, options = {}, timeout = 10000) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);

            try {
                const response = await fetchWithAuth(url, {
                    ...options,
                    signal: controller.signal
                });
                clearTimeout(timeoutId);
                return response;
            } catch (error) {
                clearTimeout(timeoutId);
                if (error.name === 'AbortError') {
                    console.warn('‚è±Ô∏è Timeout: La petici√≥n tard√≥ m√°s de', timeout/1000, 'segundos');
                    throw new Error('TIMEOUT');
                }
                throw error;
            }
        }

        // Mostrar/ocultar spinner de actualizaci√≥n (esquina superior derecha)
        function showUpdateSpinner(show) {
            let spinner = document.getElementById('update-spinner');
            if (!spinner && show) {
                // Crear spinner si no existe
                spinner = document.createElement('div');
                spinner.id = 'update-spinner';
                spinner.style.cssText = 'position: fixed; top: 80px; right: 20px; z-index: 9999; background: rgba(255,255,255,0.95); padding: 10px 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.15); display: flex; align-items: center; gap: 10px;';
                spinner.innerHTML = `
                    <div class="spinner-border spinner-border-sm text-primary" role="status"></div>
                    <small class="text-muted">Actualizando...</small>
                `;
                document.body.appendChild(spinner);
            } else if (spinner) {
                spinner.style.display = show ? 'flex' : 'none';
            }
        }

        // --- UTILIDADES URL ---
        function getParameterByName(name) {
            var url = window.location.href;
            name = name.replace(/[\[\]]/g, "\\$&");
            var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)"), results = regex.exec(url);
            if (!results) return null;
            if (!results[2]) return '';
            return decodeURIComponent(results[2].replace(/\+/g, " "));
        }
        function eraseEnd(name){ return name.replace(/\?.*$/g, " "); }

        const roomId = getParameterByName('roomId');
        const deviceId = getParameterByName('deviceId');
        let roomname = getParameterByName('roomname');
        let devicename = getParameterByName('devicename');

        function displayRoomName() {
            devicename = eraseEnd(devicename);
            roomname = eraseEnd(roomname);
            document.getElementById("deviceName").innerHTML = devicename;
            document.getElementById("deviceRoute").innerHTML = devicename;
            document.getElementById("roomRoute").innerHTML = roomname;
        }
        displayRoomName();

        // --- 1. CARGA INICIAL ---
        async function loadDeviceInfo() {
            try {
                const response = await fetchWithAuth(`${API_URL}/devices/${deviceId}`);
                if (!response.ok) throw new Error('Error al cargar informaci√≥n');
                const data = await response.json();
                deviceData = data.data;

                setupInterfaceByType(deviceData.tipo, deviceData.subtipo);
                updateToggleState(deviceData.estado);
                await fetchHistoricalData();

            } catch (error) {
                console.error('Error:', error);
                swal("Error", "No se pudo cargar el dispositivo", "error");
            }
        }

        function updateToggleState(estado) {
            const toggle = document.getElementById('device-toggle');
            const taskname = document.getElementById('taskname');
            if(toggle) {
                const isOn = (typeof estado === 'object') ? estado.encendido : estado;
                toggle.checked = isOn;
                if(taskname) taskname.textContent = isOn ? 'Encendido' : 'Apagado';
            }
        }

        // --- 2. CONFIGURACI√ìN DE INTERFAZ ---
        function setupInterfaceByType(tipo, subtipo) {
            const toggleSection = document.getElementById('toggle-section');
            const tasksSection = document.getElementById('tasks-section');
            const chartContainer = document.getElementById('chart-container');
            const historyContainer = document.getElementById('history-container');

            const tipoNorm = tipo ? tipo.toLowerCase() : '';
            const subtipoNorm = subtipo ? subtipo.toLowerCase() : '';

            // Ocultar todo por defecto
            toggleSection.style.setProperty('display', 'none', 'important');
            tasksSection.style.setProperty('display', 'none', 'important');
            chartContainer.style.setProperty('display', 'none', 'important');
            historyContainer.style.setProperty('display', 'none', 'important');

            console.log('üîç Tipo de dispositivo:', tipoNorm, 'Subtipo:', subtipoNorm);

            // Actuadores - toggle, secci√≥n tareas y gr√°fica/historial seg√∫n subtipo
            if (tipoNorm === 'actuador') {
                toggleSection.style.setProperty('display', 'flex', 'important');
                tasksSection.style.setProperty('display', 'block', 'important');

                // Alarmas muestran historial, otros muestran gr√°fica
                if (subtipoNorm === 'alarma') {
                    historyContainer.style.setProperty('display', 'block', 'important');
                    console.log('‚úÖ Es actuador (alarma) - mostrando toggle, tareas e historial');
                } else {
                    chartContainer.style.setProperty('display', 'block', 'important');
                    console.log('‚úÖ Es actuador - mostrando toggle, tareas y gr√°fica');
                }
            }
            // Dispositivos con toggle pero SIN tareas (luces, focos, ventiladores)
            else if (['luces', 'foco', 'ventilador'].includes(tipoNorm)) {
                toggleSection.style.setProperty('display', 'flex', 'important');
                chartContainer.style.setProperty('display', 'block', 'important');
                console.log('‚ÑπÔ∏è Dispositivo con toggle - SIN tareas');
            }
            // Eventos (Alarmas, movimiento, etc.) - solo historial
            else if (['alarma', 'movimiento', 'pir', 'luz', 'ldr'].includes(tipoNorm)) {
                historyContainer.style.setProperty('display', 'block', 'important');
                console.log('‚ÑπÔ∏è Es sensor de eventos - mostrando historial');
            }
            // Sensores (temperatura, humedad, gas, etc.) - solo gr√°fica
            else {
                chartContainer.style.setProperty('display', 'block', 'important');
                console.log('‚ÑπÔ∏è Es sensor - mostrando gr√°fica');
            }
        }

        // --- 3. OBTENER DATOS ---
        async function fetchHistoricalData() {
            if (isLoadingData) {
                console.log('‚è≥ Ya hay una carga en progreso, ignorando...');
                return;
            }

            isLoadingData = true;
            showUpdateSpinner(true);

            // Si hay datos en cach√© para este rango, mostrarlos inmediatamente
            const cache = cachedData[currentTimeRange];
            if (cache.aggregated.length > 0 || cache.historical.length > 0) {
                console.log('üíæ Mostrando datos en cach√© mientras se actualiza...');
                historicalData = cache.historical;
                aggregatedData = cache.aggregated;
                renderDataView();
            }

            try {
                const tipo = deviceData.tipo.toLowerCase();
                let newHistoricalData = [];
                let newAggregatedData = [];

                // Petici√≥n 1: Datos completos para vida √∫til (solo para actuadores)
                if (tipo === 'actuador' || ['luces', 'foco', 'ventilador'].includes(tipo)) {
                    try {
                        const responseAll = await fetchWithTimeout(
                            `${API_URL}/devices/${deviceId}/data?limit=2000`,
                            {},
                            10000
                        );
                        if (responseAll.ok) {
                            const resultAll = await responseAll.json();
                            newHistoricalData = resultAll.data || [];
                            console.log('‚úÖ Datos completos cargados:', newHistoricalData.length, 'registros');
                        }
                    } catch (error) {
                        console.warn('‚ö†Ô∏è Error/timeout en datos completos, usando cach√©');
                        newHistoricalData = cache.historical;
                    }
                }

                // Petici√≥n 2: Datos agregados para gr√°ficas
                console.log(`üåê Fetching con timeout (10s): ${API_URL}/devices/${deviceId}/data?aggregate=${currentTimeRange}`);
                try {
                    const responseAgg = await fetchWithTimeout(
                        `${API_URL}/devices/${deviceId}/data?aggregate=${currentTimeRange}`,
                        {},
                        10000
                    );
                    console.log(`üì° Response status: ${responseAgg.status} ${responseAgg.ok ? 'OK' : 'ERROR'}`);

                    if (responseAgg.ok) {
                        const resultAgg = await responseAgg.json();
                        console.log('üì¶ Respuesta completa del backend:', JSON.stringify(resultAgg).substring(0, 500));
                        newAggregatedData = resultAgg.data || [];
                        console.log(`‚úÖ Datos agregados (${currentTimeRange}) cargados:`, newAggregatedData.length, 'puntos');

                        // Guardar en cach√©
                        cachedData[currentTimeRange].aggregated = newAggregatedData;
                        cachedData[currentTimeRange].historical = newHistoricalData;
                    } else {
                        console.warn('‚ö†Ô∏è Error del servidor, usando datos en cach√©');
                        newAggregatedData = cache.aggregated;
                    }
                } catch (error) {
                    if (error.message === 'TIMEOUT') {
                        console.warn('‚è±Ô∏è Timeout de 10s alcanzado, mostrando datos en cach√© disponibles');
                    } else {
                        console.error('‚ùå Error de red:', error.message);
                    }
                    newAggregatedData = cache.aggregated;
                }

                // Actualizar variables globales
                historicalData = newHistoricalData;
                aggregatedData = newAggregatedData;

                // Para dispositivos no actuadores, usar datos agregados tambi√©n como hist√≥ricos
                if (!historicalData || historicalData.length === 0) {
                    historicalData = aggregatedData;
                }

                renderDataView();
            } catch (error) {
                console.error('‚ùå Error general:', error);
                // Usar cach√© si existe
                historicalData = cache.historical;
                aggregatedData = cache.aggregated;
                renderDataView();
            } finally {
                isLoadingData = false;
                showUpdateSpinner(false);
            }
        }

        // --- 4. CONTROLADOR DE VISTAS ---
        function changeTimeRange(range) {
            currentTimeRange = range;
            document.querySelectorAll('.btn-group .btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(`btn-${range}`)?.classList.add('active');
            // Recargar datos agregados con el nuevo rango
            fetchHistoricalData();
        }
        function renderHeaderValue() {
            const badge = document.getElementById('title-live-value');
            if (!badge) return;

            // 1. Verificar si hay datos
            if (!historicalData || historicalData.length === 0) {
                badge.style.display = 'none';
                return;
            }

            // 2. Verificar tipo
            const tipo = deviceData.tipo ? deviceData.tipo.toLowerCase() : '';
            const subtipo = deviceData.subtipo ? deviceData.subtipo.toLowerCase() : '';
            
            const allowedTypes = ['temperatura', 'temp', 'humedad', 'humidity', 'gas', 'mq2', 'calidad aire'];
            const isAllowed = allowedTypes.some(t => tipo.includes(t) || subtipo.includes(t));

            if (!isAllowed) {
                badge.style.display = 'none';
                return;
            }

            // 3. Obtener valor
            const sorted = [...historicalData].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            const lastVal = sorted[0].valor;

            // 4. DEFINIR ESTILOS "SOFT" (Fondo suave, texto fuerte)
            let unit = '';
            // Estilos base para que se vea elegante (padding, fuente, borde)
            let baseStyle = "display: inline-block; padding: 5px 15px; border-radius: 12px; font-weight: 600; font-size: 1.1rem; vertical-align: middle;";
            let specificStyle = "";

            if (tipo.includes('temp') || subtipo.includes('temp')) {
                unit = '¬∞C';
                // Fondo rojo muy suave (#ffebee) y texto rojo oscurito (#c62828)
                specificStyle = "background-color: #ffebee; color: #c62828; border: 1px solid #ffcdd2;";
            } else if (tipo.includes('hum') || subtipo.includes('hum')) {
                unit = '%';
                // Fondo azul muy suave (#e3f2fd) y texto azul oscurito (#1565c0)
                specificStyle = "background-color: #e3f2fd; color: #1565c0; border: 1px solid #bbdefb;";
            } else if (tipo.includes('gas') || subtipo.includes('gas')) {
                unit = ' ppm';
                // Fondo amarillo suave (#fff8e1) y texto naranja/ambar (#f57f17)
                specificStyle = "background-color: #fff8e1; color: #f57f17; border: 1px solid #ffecb3;";
            }

            // 5. Renderizar
            // Limpiamos las clases de bootstrap que estorban (bg-primary, etc)
            badge.className = 'ms-3'; 
            // Aplicamos los estilos directos
            badge.style.cssText = baseStyle + specificStyle;
            badge.innerHTML = `${lastVal}${unit}`;
        }        
        function renderDataView() {
            const tipo = deviceData.tipo.toLowerCase();
            const subtipo = deviceData.subtipo ? deviceData.subtipo.toLowerCase() : '';

            renderHeaderValue();

            console.log('üé® Renderizando vista para tipo:', tipo, 'subtipo:', subtipo);
            console.log('üìÅ Total datos hist√≥ricos:', historicalData.length);
            console.log('üìä Datos agregados:', aggregatedData.length);

            // Usar datos agregados para las gr√°ficas (ya vienen filtrados por el backend)
            const dataForChart = aggregatedData;
            console.log('üîç Datos para gr√°fica:', dataForChart.length);

            // Actuadores con subtipo alarma ‚Üí historial
            if (tipo === 'actuador' && subtipo === 'alarma') {
                console.log('‚Üí Renderizando historial de eventos (actuador alarma)');
                // Usar aggregatedData porque ya vienen filtrados del backend
                renderHistoryList(aggregatedData, 'alarma');
            }
            // Actuadores (luz, ventilador o sin subtipo) ‚Üí gr√°fica de uso
            else if (tipo === 'actuador' || ['luces', 'foco', 'ventilador'].includes(tipo)) {
                console.log('‚Üí Renderizando gr√°fica de uso');
                // PASAMOS datos agregados para gr√°fica, hist√≥ricos completos para vida √∫til
                renderUsageChart(dataForChart, tipo, historicalData);
            }
            // Sensores de eventos ‚Üí historial (movimiento, luz, etc.)
            else if (['alarma', 'movimiento', 'pir', 'luz', 'ldr'].includes(tipo)) {
                console.log('‚Üí Renderizando historial de eventos (sensor)');
                // Usar aggregatedData porque ya vienen filtrados del backend
                renderHistoryList(aggregatedData, tipo);
            }
            // Sensores de medici√≥n ‚Üí gr√°fica de l√≠nea (USAR DATOS AGREGADOS)
            else {
                console.log('‚Üí Renderizando gr√°fica de l√≠nea (sensor) con datos agregados');
                renderLineChart(dataForChart, tipo);
            }
        }

        function filterDataByTime(data, range) {
            const now = new Date();
            const timeLimit = new Date();
            if (range === '24h') timeLimit.setHours(now.getHours() - 24);
            else if (range === '7d') timeLimit.setDate(now.getDate() - 7);
            else if (range === '30d') timeLimit.setDate(now.getDate() - 30);
            return data.filter(item => new Date(item.timestamp) >= timeLimit);
        }

        // --- 4.5 MOSTRAR √öLTIMA LECTURA ---
        function showLastReadingInfo() {
            // Buscar el contenedor existente o crearlo
            let infoDiv = document.getElementById('last-reading-info');

            if (!historicalData || historicalData.length === 0) {
                // Si no hay datos, ocultar el div si existe
                if (infoDiv) infoDiv.style.display = 'none';
                return;
            }

            // Encontrar el registro m√°s reciente
            const sortedData = [...historicalData].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            const lastReading = sortedData[0];
            const lastDate = new Date(lastReading.timestamp);

            // Formatear fecha
            const dateStr = lastDate.toLocaleDateString('es-MX', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
            const timeStr = lastDate.toLocaleTimeString('es-MX', {
                hour: '2-digit',
                minute: '2-digit'
            });

            // Calcular tiempo transcurrido
            const now = new Date();
            const diffMs = now - lastDate;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMins / 60);
            const diffDays = Math.floor(diffHours / 24);

            let timeAgo = '';
            if (diffMins < 1) timeAgo = 'Hace menos de un minuto';
            else if (diffMins < 60) timeAgo = `Hace ${diffMins} minuto${diffMins > 1 ? 's' : ''}`;
            else if (diffHours < 24) timeAgo = `Hace ${diffHours} hora${diffHours > 1 ? 's' : ''}`;
            else timeAgo = `Hace ${diffDays} d√≠a${diffDays > 1 ? 's' : ''}`;

            // Crear o actualizar el div
            if (!infoDiv) {
                infoDiv = document.createElement('div');
                infoDiv.id = 'last-reading-info';
                infoDiv.className = 'alert alert-info d-flex justify-content-between align-items-center mb-3';

                const chartContainer = document.getElementById('chart-container');
                chartContainer.insertBefore(infoDiv, chartContainer.firstChild);
            }

            infoDiv.style.display = 'flex';
            infoDiv.innerHTML = `
                <div>
                    <strong>üìä √öltima lectura:</strong> ${dateStr} a las ${timeStr}
                </div>
                <small class="text-muted">${timeAgo}</small>
            `;
        }

        // --- 5. HISTORIAL ---
        function renderHistoryList(data, tipo) {
            console.log(`üìã renderHistoryList llamado - tipo: ${tipo}, datos recibidos: ${data.length}`);
            console.log('üìä Rango actual:', currentTimeRange);
            if (data.length > 0) {
                console.log('üîç Primer dato:', data[0]);
                console.log('üîç √öltimo dato:', data[data.length - 1]);
            }

            const list = document.getElementById('history-list');
            if(!list) return;

            // Mostrar informaci√≥n de √∫ltima lectura
            showLastReadingInfo();

            list.innerHTML = '';
            const hasAnyData = historicalData && historicalData.length > 0;

            if (data.length === 0) {
                console.warn('‚ö†Ô∏è No hay datos para mostrar en el historial');
                console.log('   historicalData.length:', historicalData ? historicalData.length : 'null');
                console.log('   aggregatedData.length:', aggregatedData ? aggregatedData.length : 'null');
                if (!hasAnyData) {
                    list.innerHTML = `
                        <div class="list-group-item text-center">
                            <div class="spinner-border text-primary spinner-border-sm mb-2" role="status"></div>
                            <p class="text-muted mb-0">Esperando eventos...</p>
                        </div>
                    `;
                } else {
                    list.innerHTML = `
                        <div class="list-group-item text-center">
                            <div style="font-size: 2rem; margin-bottom: 10px;">‚ÑπÔ∏è</div>
                            <p class="text-muted mb-0 mt-2">No hay eventos en este rango de tiempo</p>
                            <small class="text-muted">Selecciona otro rango para ver el historial</small>
                        </div>
                    `;
                }
                return;
            }

            // Los datos ya vienen consolidados desde el backend con timestamp y timestampEnd
            let itemsRendered = 0;
            data.forEach((range, index) => {
                console.log(`üî® Procesando evento ${index + 1}/${data.length}:`, range);
                const startDate = new Date(range.timestamp);
                const endDate = new Date(range.timestampEnd || range.timestamp);

                // Formatear fechas y horas
                const dateStr = startDate.toLocaleDateString('es-MX', {
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric'
                });
                const startTimeStr = startDate.toLocaleTimeString('es-MX', {
                    hour: '2-digit',
                    minute: '2-digit'
                });
                const endTimeStr = endDate.toLocaleTimeString('es-MX', {
                    hour: '2-digit',
                    minute: '2-digit'
                });

                // Determinar mensaje y estilo seg√∫n el tipo de dispositivo
                const valStr = String(range.valor).toUpperCase();
                const isOn = (valStr === 'ON' || valStr === 'ENCENDIDO' || valStr === '1' || valStr === 'TRUE' || valStr === 'ACTIVADA');

                let message = `Valor: ${range.valor}`;
                let cssClass = 'event-info';

                if (['movimiento', 'pir'].includes(tipo)) {
                    message = isOn ? '‚ÄºÔ∏è Movimiento Detectado' : 'Sin movimiento';
                    cssClass = isOn ? 'event-alert' : 'event-info';
                } else if (tipo === 'alarma') {
                    message = isOn ? 'üö® Alarma Disparada' : 'Alarma Silenciada';
                    cssClass = isOn ? 'event-alert' : 'event-success';
                } else if (['luz', 'ldr'].includes(tipo)) {
                    const esOscuro = !isOn;
                    message = esOscuro ? 'üåô Oscuridad Detectada' : '‚òÄÔ∏è Luz Detectada';
                    cssClass = esOscuro ? 'event-info' : 'event-success';
                }

                // Crear el rango de tiempo
                const timeRange = startTimeStr === endTimeStr
                    ? startTimeStr
                    : `${startTimeStr} - ${endTimeStr}`;

                const origen = range.metadata?.origen ? `<span class="badge bg-secondary ms-2">${range.metadata.origen}</span>` : '';

                const htmlItem = `
                    <div class="list-group-item ${cssClass}">
                        <div class="d-flex w-100 justify-content-between align-items-center">
                            <div>
                                <h6 class="mb-0">${message}</h6>
                                ${origen}
                            </div>
                            <div class="text-end ms-2">
                                <small class="text-muted d-block">${dateStr}</small>
                                <small class="text-muted"><strong>${timeRange}</strong></small>
                            </div>
                        </div>
                    </div>
                `;

                list.innerHTML += htmlItem;
                itemsRendered++;
                console.log(`‚úÖ Item ${itemsRendered} agregado: ${message} | ${timeRange}`);
            });

            console.log(`üéâ Renderizado completo: ${itemsRendered} items en el DOM`);
            console.log('üìè HTML length:', list.innerHTML.length);
        }

        // --- 6. GR√ÅFICA DE USO (Focos, Ventiladores) - CORREGIDA ---
        function renderUsageChart(dataFiltered, tipo, dataTotal) {
            console.log('üìä renderUsageChart llamado');
            console.log('üìä dataFiltered:', dataFiltered.length);
            console.log('üìä dataTotal:', dataTotal.length);

            const overlay = document.getElementById('chart-overlay');
            const ctx = document.getElementById('myChart');
            if (myChart) myChart.destroy();

            // Verificar si hay datos hist√≥ricos en absoluto
            const hasAnyData = historicalData && historicalData.length > 0;
            console.log('‚úÖ hasAnyData (actuador):', hasAnyData);

            // Mostrar informaci√≥n de √∫ltima lectura
            showLastReadingInfo();

            // Si no hay datos en el rango actual, mostrar placeholder
            if (!dataFiltered || dataFiltered.length === 0) {
                const statsDiv = document.getElementById('usage-stats');
                if(statsDiv) statsDiv.remove();

                const placeholderLabels = ['00:00', '04:00', '08:00', '12:00', '16:00', '20:00'];
                const placeholderValues = [15, 30, 10, 45, 20, 35];

                myChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: placeholderLabels,
                        datasets: [{
                            label: 'Minutos de Uso',
                            data: placeholderValues,
                            backgroundColor: 'rgba(200, 200, 200, 0.4)',
                            borderColor: 'rgba(200, 200, 200, 0.6)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        scales: { y: { beginAtZero: true, title: {display: true, text: 'Minutos'} } },
                        plugins: { title: { display: true, text: 'Uso por Hora' }, legend: { display: false } }
                    }
                });

                // Solo mostrar "Esperando datos..." si NO hay ning√∫n dato hist√≥rico
                if (!hasAnyData) {
                    overlay.innerHTML = `
                        <div class="spinner-border text-primary mb-2" role="status"></div>
                        <span class="text-muted">Esperando datos del dispositivo...</span>
                    `;
                    overlay.style.display = 'flex';
                } else {
                    // Hay datos hist√≥ricos pero no en este rango
                    overlay.innerHTML = `
                        <div class="text-center">
                            <div style="font-size: 2.5rem; margin-bottom: 10px;">‚ÑπÔ∏è</div>
                            <p class="text-muted mb-0 mt-2">No hay datos de uso en este rango</p>
                            <small class="text-muted">Selecciona otro rango para ver el historial</small>
                        </div>
                    `;
                    overlay.style.display = 'flex';
                }
                return;
            }

            // Ocultar overlay cuando hay datos
            overlay.style.display = 'none';

            // 1. C√ÅLCULO DE VIDA √öTIL (Usando dataTotal = Todo el historial)
            let vidaUtilTotalHoras = 10000;
            if (tipo.includes('foco') || tipo.includes('luz')) vidaUtilTotalHoras = 15000;
            else if (tipo.includes('ventilador')) vidaUtilTotalHoras = 20000;

            const totalMinutesUsed = calculateTotalUsage(dataTotal);
            const totalHoursUsed = totalMinutesUsed / 60;

            let porcentajeRestante = 100 - ((totalHoursUsed / vidaUtilTotalHoras) * 100);
            if (porcentajeRestante < 0) porcentajeRestante = 0;

            let colorBarra = 'bg-success';
            if (porcentajeRestante < 50) colorBarra = 'bg-warning';
            if (porcentajeRestante < 10) colorBarra = 'bg-danger';

            // Inyectar HTML de Vida √ötil
            const chartContainer = document.getElementById('chart-container');
            let statsDiv = document.getElementById('usage-stats');
            if (!statsDiv) {
                statsDiv = document.createElement('div');
                statsDiv.id = 'usage-stats';
                statsDiv.className = 'card p-3 mb-3 bg-light';
                chartContainer.prepend(statsDiv);
            }
            statsDiv.innerHTML = `
                <div class="d-flex justify-content-between align-items-center mb-1">
                    <strong>Vida √ötil Restante:</strong>
                    <span class="${porcentajeRestante < 10 ? 'text-danger fw-bold' : 'text-dark'}">
                        ${porcentajeRestante.toFixed(2)}%
                    </span>
                </div>
                <div class="progress" style="height: 15px;">
                    <div class="progress-bar ${colorBarra}" style="width: ${porcentajeRestante}%"></div>
                </div>
                <small class="text-muted d-block mt-1">Horas totales usadas: ${totalHoursUsed.toFixed(2)} hrs</small>
            `;

            // 2. GR√ÅFICA DETALLADA (Usando dataFiltered)
            const aggregatedData = aggregateUsageByPeriod(dataFiltered, currentTimeRange);

            myChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: aggregatedData.labels,
                    datasets: [{
                        label: 'Minutos de Uso',
                        data: aggregatedData.values,
                        backgroundColor: 'rgba(75, 192, 192, 0.6)',
                        borderColor: 'rgba(75, 192, 192, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: { beginAtZero: true, title: {display: true, text: 'Minutos'} }
                    },
                    plugins: {
                        title: { display: true, text: `Uso por ${currentTimeRange === '24h' ? 'Hora' : 'D√≠a'}` },
                        legend: { display: false }
                    }
                }
            });
        }

        // --- NUEVA L√ìGICA DE AGREGACI√ìN (BARRAS DIVIDIDAS) ---
        function aggregateUsageByPeriod(data, range) {
            const labels = [];
            const values = [];
            const buckets = {}; // Mapa para sumar minutos por hora/d√≠a

            // 1. Inicializar cubetas
            const now = new Date();
            if (range === '24h') {
                // Crear 24 cubetas para las √∫ltimas 24h
                for(let i=23; i>=0; i--) {
                    const d = new Date(now);
                    d.setHours(d.getHours() - i);
                    const label = d.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    buckets[label] = 0;
                    labels.push(label);
                }
            } else {
                // Crear cubetas por d√≠a (7 o 30)
                const days = range === '7d' ? 7 : 30;
                for(let i=days-1; i>=0; i--) {
                    const d = new Date(now);
                    d.setDate(d.getDate() - i);
                    const label = d.toLocaleDateString();
                    buckets[label] = 0;
                    labels.push(label);
                }
            }

            // 2. Calcular duraciones y llenar cubetas
            // Necesitamos ordenar cronol√≥gicamente
            const sorted = [...data].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            let lastOnTime = null;

            for (let i = 0; i < sorted.length; i++) {
                const item = sorted[i];
                const val = String(item.valor).toUpperCase();
                const isOn = (val === 'ON' || val === 'ENCENDIDO' || val === '1');
                const timestamp = new Date(item.timestamp);

                if (isOn) {
                    if (!lastOnTime) lastOnTime = timestamp;
                } else {
                    if (lastOnTime) {
                        // Encontr√≥ un apagado, calculamos duraci√≥n
                        const diffMs = timestamp - lastOnTime;
                        const minutes = diffMs / 1000 / 60;

                        // Asignar a la cubeta correspondiente (simplificado: a la hora de inicio)
                        let key;
                        if (range === '24h') key = lastOnTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                        else key = lastOnTime.toLocaleDateString();

                        // Solo sumar si la cubeta existe en el rango actual
                        if (buckets[key] !== undefined) {
                            buckets[key] += minutes;
                        }
                        lastOnTime = null;
                    }
                }
            }
            
            // Si sigue encendido hasta "ahora"
            if (lastOnTime) {
                const diffMs = new Date() - lastOnTime;
                const minutes = diffMs / 1000 / 60;
                let key;
                if (range === '24h') key = lastOnTime.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                else key = lastOnTime.toLocaleDateString();
                
                if (buckets[key] !== undefined) buckets[key] += minutes;
            }

            // Convertir mapa a array alineado con labels
            labels.forEach(label => {
                values.push(buckets[label] || 0);
            });

            return { labels, values };
        }

        function calculateTotalUsage(data) {
            const sorted = [...data].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            let totalMs = 0;
            let lastOnTime = null;
            sorted.forEach(item => {
                const val = String(item.valor).toUpperCase();
                const isOn = (val === 'ON' || val === 'ENCENDIDO' || val === '1' || val === 'TRUE');
                if (isOn) { if (!lastOnTime) lastOnTime = new Date(item.timestamp); } 
                else { if (lastOnTime) { totalMs += (new Date(item.timestamp) - lastOnTime); lastOnTime = null; } }
            });
            if (lastOnTime) totalMs += (new Date() - lastOnTime);
            return totalMs / 1000 / 60;
        }

        // --- 7. SENSORES RANGO (OPTIMIZADO CON DATOS AGREGADOS) ---
        function renderLineChart(data, tipo) {
            console.log('üìà renderLineChart llamado con:', data.length, 'datos agregados');

            const statsDiv = document.getElementById('usage-stats');
            if(statsDiv) statsDiv.remove();
            const ctx = document.getElementById('myChart');
            const overlay = document.getElementById('chart-overlay');
            if (myChart) myChart.destroy();

            let color = 'rgba(54, 162, 235, 1)';
            let title = 'Valor';
            if (tipo.includes('temp')) { color = 'rgba(255, 99, 132, 1)'; title = 'Temperatura (¬∞C)'; }
            else if (tipo.includes('hum')) { color = 'rgba(54, 162, 235, 1)'; title = 'Humedad (%)'; }
            else if (tipo.includes('gas')) { color = 'rgba(255, 206, 86, 1)'; title = 'Gas (ppm)'; }

            // Verificar si hay datos agregados
            const hasAnyData = aggregatedData && aggregatedData.length > 0;
            console.log('‚úÖ hasAnyData (agregados):', hasAnyData);

            // Mostrar informaci√≥n de √∫ltima lectura
            showLastReadingInfo();

            if (!data || data.length === 0) {
                console.log('‚ö†Ô∏è No hay datos agregados, mostrando placeholder');

                // Datos placeholder para la gr√°fica de fondo
                const placeholderLabels = ['00:00', '04:00', '08:00', '12:00', '16:00', '20:00', '24:00'];
                const placeholderValues = [22, 24, 26, 28, 27, 25, 23];

                myChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: placeholderLabels,
                        datasets: [{
                            label: title, data: placeholderValues, borderColor: 'rgba(200, 200, 200, 0.5)', backgroundColor: 'rgba(200, 200, 200, 0.1)',
                            borderWidth: 2, fill: true, tension: 0.4
                        }]
                    },
                    options: { responsive: true, scales: { y: { beginAtZero: true } } }
                });

                // Solo mostrar "Esperando datos..." si NO hay ning√∫n dato
                if (!hasAnyData) {
                    console.log('üîÑ No hay datos - mostrando spinner');
                    overlay.innerHTML = `
                        <div class="spinner-border text-primary mb-2" role="status"></div>
                        <span class="text-muted">Esperando datos del sensor...</span>
                    `;
                    overlay.style.display = 'flex';
                } else {
                    console.log('‚ÑπÔ∏è Hay datos pero no en este rango - mostrando mensaje');
                    overlay.innerHTML = `
                        <div class="text-center">
                            <div style="font-size: 2.5rem; margin-bottom: 10px;">‚ÑπÔ∏è</div>
                            <p class="text-muted mb-0 mt-2">No hay datos en este rango de tiempo</p>
                            <small class="text-muted">Selecciona otro rango o espera nuevas lecturas</small>
                        </div>
                    `;
                    overlay.style.display = 'flex';
                }
                return;
            }

            console.log('‚úÖ Hay datos agregados para mostrar, renderizando gr√°fica optimizada');

            // Ocultar overlay cuando hay datos
            overlay.style.display = 'none';

            // Los datos ya vienen ordenados del backend
            const sortedData = data.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));

            // Formatear etiquetas seg√∫n el rango
            const labels = sortedData.map(item => {
                const d = new Date(item.timestamp);
                if (currentTimeRange === '24h') {
                    return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
                } else {
                    return d.toLocaleDateString('es-MX', {month: 'short', day: 'numeric'});
                }
            });

            // Usar el promedio calculado por el backend
            const values = sortedData.map(item => item.avg || item.valor);

            myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: title,
                        data: values,
                        borderColor: color,
                        backgroundColor: color.replace('1)', '0.1)'),
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4,
                        pointRadius: 3,
                        pointHoverRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: title
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: currentTimeRange === '24h' ? 'Hora' : 'Fecha'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    const item = sortedData[context.dataIndex];
                                    if (item.count > 1) {
                                        return `Promedio de ${item.count} lecturas`;
                                    }
                                    return '';
                                }
                            }
                        }
                    }
                }
            });
        }

        const toggle = document.getElementById('device-toggle');
        toggle.addEventListener('change', async (e) => {
            const newState = e.target.checked;
            const taskname = document.getElementById('taskname');
            taskname.textContent = newState ? 'Encendido' : 'Apagado';
            try {
                const response = await fetchWithAuth(`${API_URL}/devices/${deviceId}/toggle`, { method: 'PUT' });
                if (!response.ok) throw new Error('Error');
                setTimeout(fetchHistoricalData, 500);
            } catch (error) {
                swal("Error", "No se pudo cambiar el estado", "error");
                e.target.checked = !newState;
                taskname.textContent = !newState ? 'Encendido' : 'Apagado';
            }
        });

        function sendName(){ window.location.href = `devices.html?roomId=${roomId}&roomname=${roomname}`; }
        function sendTaskInfo(){ window.location.href = `addtask.html?deviceId=${deviceId}&devicename=${devicename}&roomId=${roomId}&roomname=${roomname}`; }
        function sendTask(){ var taskname = document.getElementById("taskname").textContent; window.location.href = `taskdata.html?deviceId=${deviceId}&devicename=${devicename}&roomId=${roomId}&roomname=${roomname}&taskname=${taskname}`; }
        loadDeviceInfo();
    </script>
</body>
</html>